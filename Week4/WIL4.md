1. CSS / 계산기의 틀 대로 만든 html에 취향대로 css를 입력해보았다. 버튼 간격이 감이 안 잡혀서 디버깅 페이지에서 이것저것 고쳐보며 간격을 맞추었다. 폰트는 옛날 계산기의 느낌을 살리고 싶어 도트 느낌의 글꼴을 사용했다. 버튼의 종류 별로 색상도 설정했다. 추가로 button:active를 사용해서 그림자를 추가해 버튼이 눌리는 효과를 구현해보았다.

2. JS /

CSS는 이제 좀 감이 잡히는데 아직도 JS코드를 짜는 것은 잘 모르겠어서 이번 과제도 일단 다른 사람들의 코드를 여러개 읽어보고, 또 과제 예시 페이지 코드를 읽어보며 궁금한 부분을 구글링하면서 지식을 쌓아보는 것을 목표로 진행했다. (중간고사 이후 JS 문법 공부를 따로 해야겠다.)
우선 계산기를 구현하기 위해서 계산기를 관찰하고 작동방식을 생각해보았다. 버튼이 눌리는 event에 따라 값을 받아 display 부분에 띄우고 그 값을 저장, 이후 연산자와 또 다른 값 하나를 받아 저장한 값과 연산을 진행하고 그 값을 다시 display에 띄우는 동작을 한다. 이 때 계산에 오류가 생기는 수식이면 NaN을 띄워야 할 것이다. 또 All Clear 버튼을 누르면 초기화가 될 것이다. AC 버튼은 계산 중에는 C 버튼이 된다.

- DomContentLoaded
  Dom tree의 분석이 끝나면 발생하는 코드이다. 즉, 돔트리가 다 만들어진 후에 돔에 접근이 가능하기때문에, 돔이 생성되기전 돔을 조작하는 자바스크립트 코드가 실행되어 원하지 않는 결과를 내는것을 막을 수 있다. 웹 문서를 만들때, '문서가 로드되는 시점'에 발생하는 이벤트로 주로 DOMContentLoaded와 onload를 사용한다.

  > 두 이벤트의 차이 : DOMContentLoaded는 DOM 트리를 완성하는 즉시 발생한다. onload는 문서의 모든 콘텐츠(images, script, css, etc)가 로드되었을 때 실행된다. 즉 DOMContentLoaded가 onload보다 먼저 실행된다.

- = () => { }; (화살표 함수)
  화살표 함수 표현(arrow function expression)은 전통적인 함수표현의 간편한 대안이다.
  하지만 몇 가지 제한점이 있고 모든 상황에 사용할 수는 없다.

  > this, arguments나 super에 대한 자체 바인딩이 없고, methods로 사용해서는 안 됨
  > new.target 키워드가 없음
  > 일반적으로 스코프를 지정할 때 사용하는 call, apply, bind methods를 이용할 수 없음
  > 생성자(Constructor)로 사용할 수 없음
  > yield를 화살표 함수 내부에서 사용할 수 없음

- parseFloat() : string을 float로 변환

- element.innerText; : element 안의 text 값들만을 가져온다.
- element.innerHTML; : innerText와는 달리 element 안의 HTML이나 XML을 가져온다.

- e.target : 이벤트가 발생한 대상 객체를 가리키며, 이벤트가 발생한 요소를 반환해준다. 현재 이벤트가 발생한 요소의 속성들을 얻을 수 있다. 예를 들어 이벤트가 발생한 대상의 id를 출력하려면 event.target.id를 통해 진행할 수 있다.
